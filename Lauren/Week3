import cv2
import numpy as np
from skimage.metrics import structural_similarity as ssim
from skimage import io

# Load two stained images; both H&E for the time being 
img1 = cv2.imread('image1.png', 0)  # Image from stain 1
img2 = cv2.imread('image2.png', 0)  # Image from stain 2

# Edge Detection to highlight structural features
edges1 = cv2.Canny(img1, 100, 200)
edges2 = cv2.Canny(img2, 100, 200)

# Feature Matching using ORB
orb = cv2.ORB_create()
keypoints1, descriptors1 = orb.detectAndCompute(edges1, None)
keypoints2, descriptors2 = orb.detectAndCompute(edges2, None)

# Use Brute Force Matcher
bf = cv2.BFMatcher(cv2.NORM_HAMMING, crossCheck=True)
matches = bf.match(descriptors1, descriptors2)
matches = sorted(matches, key=lambda x: x.distance)

# Visualize the matched features
matched_img = cv2.drawMatches(edges1, keypoints1, edges2, keypoints2, matches[:50], None, flags=2)
cv2.imshow('Matches', matched_img)
cv2.waitKey(0)
cv2.destroyAllWindows()

# Image Alignment using Affine or Homography transform
# Find the transformation matrix using matched keypoints
src_pts = np.float32([keypoints1[m.queryIdx].pt for m in matches]).reshape(-1, 1, 2)
dst_pts = np.float32([keypoints2[m.trainIdx].pt for m in matches]).reshape(-1, 1, 2)


M, _ = cv2.estimateAffinePartial2D(src_pts, dst_pts)

# align second image with the first
aligned_img2 = cv2.warpAffine(img2, M, (img1.shape[1], img1.shape[0]))

# Structural Similarity
similarity_score, diff = ssim(img1, aligned_img2, full=True)
print(f'Structural Similarity Score: {similarity_score}')


x, y, w, h = 100, 100, 50, 50  # Example ROI
patch1 = img1[y:y+h, x:x+w]
patch2 = aligned_img2[y:y+h, x:x+w]


